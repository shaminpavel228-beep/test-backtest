"""Export our simulator events CSV into a TradingView-like 'List of Trades' CSV.

This script pairs open/close events by side and order of occurrence, maps bars to dates
using the price CSV (pine/data/<TICKER>.csv) and outputs a CSV with columns similar to
TradingView's trade list: Entry Time, Exit Time, Side, Entry Price, Exit Price, Quantity,
Profit, Commission, Reason
"""
from pathlib import Path
import pandas as pd
from typing import Optional


def bar_to_datetime(price_csv: str, bar_idx: int) -> Optional[pd.Timestamp]:
    price_df = pd.read_csv(price_csv, index_col=0, parse_dates=True)
    # bar_idx expected to be an integer index into price_df
    if bar_idx is None or pd.isna(bar_idx):
        return None
    idx = int(bar_idx)
    if idx < 0 or idx >= len(price_df):
        return None
    return price_df.index[idx]


def convert_events_to_trades(events_csv: str, price_csv: str, out_path: str) -> None:
    df = pd.read_csv(events_csv)
    # Normalize columns
    df['type'] = df['type'].astype(str).str.lower()
    df['side'] = df['side'].astype(str).str.lower()
    # We'll pair open -> close sequentially per side
    trades = []

    opens = []  # list of dicts: side, price, volume, bar
    for _, row in df.iterrows():
        t = row['type']
        side = row.get('side')
        if t == 'open':
            opens.append({'side': side, 'entry_price': row.get('price'), 'quantity': row.get('volume'), 'entry_bar': row.get('bar')})
        elif t == 'close':
            # find the last open of same side (FIFO)
            match_idx = None
            for i in range(len(opens)-1, -1, -1):
                if opens[i]['side'] == side:
                    match_idx = i
                    break
            if match_idx is None:
                # unmatched close â€” record as standalone
                entry_price = None
                entry_bar = None
                quantity = None
            else:
                open_rec = opens.pop(match_idx)
                entry_price = open_rec['entry_price']
                entry_bar = open_rec['entry_bar']
                quantity = open_rec['quantity']

            exit_price = row.get('price')
            exit_bar = row.get('bar')
            profit = row.get('profit') if 'profit' in row else None
            commission = row.get('commission') if 'commission' in row else None
            reason = row.get('reason') if 'reason' in row else None

            entry_time = bar_to_datetime(price_csv, entry_bar)
            exit_time = bar_to_datetime(price_csv, exit_bar)

            trades.append({
                'Entry Time': entry_time,
                'Exit Time': exit_time,
                'Side': side,
                'Entry Price': entry_price,
                'Exit Price': exit_price,
                'Quantity': quantity,
                'Profit': profit,
                'Commission': commission,
                'Reason': reason,
            })

    out = Path(out_path)
    pd.DataFrame(trades).to_csv(out, index=False)


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description='Convert events CSV to TradingView-like trades CSV')
    parser.add_argument('--events', required=True, help='Path to events CSV generated by simulator')
    parser.add_argument('--prices', required=True, help='Path to price CSV (pine/data/<TICKER>.csv) to map bar->time')
    parser.add_argument('--out', default=None, help='Output trades CSV path')
    args = parser.parse_args()

    if args.out is None:
        p = Path(args.events)
        args.out = str(p.parent / f"tv-like-trades-{p.stem}.csv")

    convert_events_to_trades(args.events, args.prices, args.out)
    print('Wrote', args.out)
